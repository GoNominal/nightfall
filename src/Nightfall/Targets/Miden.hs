{-# LANGUAGE OverloadedLists #-}
{-# LANGUAGE OverloadedStrings #-}

module Nightfall.Targets.Miden ( Context(..)
                               , defaultContext
                               , Config(..)
                               , defaultConfig
                               , transpile
                               ) where

import Nightfall.Lang.Internal.Types as NFTypes
import Nightfall.MASM.Types as MASM
import Control.Monad.State
import Control.Monad.State.Lazy (modify)
import Data.Map ( Map )
import qualified Data.Map as Map
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as Text
import Data.Word (Word64)
import Data.List ( singleton )
import qualified Data.IntMap as MAp

-- | Index in Miden's global memory (accessed via mem_load, mem_store, etc.)
type MemIdx = Word64

-- | Transpilation configuration options
data Config = Config {
      cgfTraceVariablesDecl :: Bool     -- ^ Whether or not adding comments when declaring variables
    , cfgTraceVariablesUsage :: Bool    -- ^ Whether or not adding comments when using ("calling") variables
} deriving (Eq, Show)

defaultConfig :: Config
defaultConfig = Config
    { cgfTraceVariablesDecl = False
    , cfgTraceVariablesUsage = False
}

-- | Context for the transpilation
data Context = Context
    { memPos :: MemIdx               -- ^ Next free indice in Miden's global memory
    , variables :: Map String MemIdx -- ^ Variables in the EDSL are stored in Miden's random access memory, we keep a map to match them
    , config :: Config
    }

defaultContext :: Context
defaultContext = Context
    { memPos = 0
    , variables = Map.empty
    , config = defaultConfig
    }

-- | Entry point: transpile a EDSL-described ZK program into a Miden Module
transpile :: ZKProgram -> State Context Module
transpile zkProg = do
    warning <- transpileStatement $ comment "This program was generated by Nightfall (https://github.com/qredo/nightfall), avoid editing by hand.\n"
    midenInstr <- concat <$> mapM transpileStatement (pStatements zkProg)
    return $ Module { moduleImports = [] -- No import for now (TODO)
                    , moduleProcs = Map.empty -- No procs either (TODO)
                    , moduleProg = Program (head warning : midenInstr)
                    }

transpileStatement :: Statement -> State Context [Instruction]
transpileStatement (NFTypes.Comment str) = return . singleton . MASM.Comment . Text.pack $ str
transpileStatement (IfElse cond ifBlock elseBlock) = do
    ifBlock' <- concat <$> mapM transpileStatement ifBlock
    elseBlock' <- concat <$> mapM transpileStatement elseBlock
    cond' <- transpileExpr cond
    return $ cond' <> [ MASM.If ifBlock' elseBlock' ]
-- | Declaring a variable loads the expression into Miden's global memory, and we track the index in memory
transpileStatement (DeclVariable varname e) = do
    vars <- gets variables
    pos <- gets memPos
    cfg <- gets config

    -- Check if this variable hasn't already been declared
    when (Map.member varname vars) $ do
        error $ "Variable \"" ++ varname ++ "\" has already been declared!"
    
    -- Insert the record
    let vars' = Map.insert varname pos vars

    -- Update the context
    modify $ \s -> s { memPos = pos + 1, variables = vars' }

    -- Trace the variable declaration if configured
    let traceVar = [MASM.Comment $ "var " <> Text.pack varname | cgfTraceVariablesDecl cfg]

    -- Transpile the variable value
    e' <- transpileExpr e

    -- Return instruction for the variable value and instruction to store the value in global memory
    return $ e' <> traceVar <> [ MASM.MemStore . Just . fromIntegral $ pos ]

    -- Add Miden's instructions to load the value in global memory
    -- return . singleton . MASM.MemStore . Just . fromIntegral $ pos

-- | A (naked) function call is done by pushing the argument on the stack and caling the procedure name
transpileStatement (NakedCall fname args) = do
    args' <- concat <$> mapM transpileExpr args
    return $ args' <> [ MASM.Exec . Text.pack $ fname ]

transpileStatement (Return mE) = case mE of
    -- an empty return statement doesn't correspond to an action in Miden
    Nothing -> return []
    -- When we do have a value, we simply push it to the stack
    Just e -> transpileExpr e

transpileStatement EmptyLine = return . singleton $ MASM.EmptyL

transpileStatement _ = error "transpileStatement::TODO"


-- TODO: range check, etc.
transpileExpr :: Expr -> State Context [Instruction]
-- transpileExpr (Lit _) = error "Can't transpile standalone literal" -- should be simply push it to the stack??
-- transpileExpr (Bo _)  = error "Can't transpile standalone boolean"
-- | Literals are simply pushed onto the stack
transpileExpr (Lit felt) = return . singleton . Push . fromIntegral $ felt
transpileExpr (Bo bo) = do
    let felt = if bo then 1 else 0
    return . singleton . Push $ felt

-- | Using a variable means we fetch the value from (global) memory and push it to the stack
transpileExpr (Var varname) = do
    -- Fetch the memory location of that variable in memory, and push it to the stack
    vars <- gets variables
    case Map.lookup varname vars of
        Nothing -> error $ "Variable \"" ++ varname ++ "\" unknown."
        Just idx -> do
            shouldTrace <- gets (cfgTraceVariablesUsage . config)
            let traceVar = [MASM.Comment $ "var " <> Text.pack varname | shouldTrace]
            return $ traceVar <> [MemLoad . Just . fromIntegral $ idx]

-- | Arithmetics operations are matched to their corresponding Miden operations
transpileExpr (NFTypes.Add e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Add Nothing ]
transpileExpr (NFTypes.Sub e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Sub Nothing ]
transpileExpr (NFTypes.Mul e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Mul Nothing ]
transpileExpr (NFTypes.Div e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Div Nothing ]
transpileExpr (NFTypes.Mod e1 e2) = do
    error "No support for simple 'mod' function in Miden"
    -- e1s <- transpileExpr e1
    -- e2s <- transpileExpr e2
    -- return $ e1s <> e2s <> [ MASM.Mod? Nothing ]
transpileExpr (Equal e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Eq Nothing ]
transpileExpr (Lower e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Lt ]
transpileExpr (LowerEq e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Lte ]
transpileExpr (Greater e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Gt ]
transpileExpr (GreaterEq e1 e2) = do
    e1s <- transpileExpr e1
    e2s <- transpileExpr e2
    return $ e1s <> e2s <> [ MASM.Gte ]
transpileExpr (NFTypes.Not e) = do
    es <- transpileExpr e
    return $ es <> [ MASM.Not ]

transpileExpr _ = error "transpileExpr::TODO"

-- transpileExpr (Add e1 e2) = 

-- addInstuctions :: [Instruction]
-- addInstuctions = [ Push 33
--                  , Push 42
--                  , Add Nothing
--                  ]

-- addProg :: Program
-- addProg = Program addInstuctions

-- addModule :: Module
-- addModule = Module
--     { moduleImports = []
--     , moduleProcs = empty
--     , moduleProg = addProg
--     }
